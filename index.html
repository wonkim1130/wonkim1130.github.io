
<!DOCTYPE html>
<html>
<head>
    <title>Tetris</title>
</head>
<body>
    <canvas id="tetrisCanvas" width="240" height="400"></canvas>

    <script>
        const canvas = document.getElementById('tetrisCanvas');
        const context = canvas.getContext('2d');

        const blockSize = 20;
        const numberOfRows = canvas.height / blockSize;
        const numberOfColumns = canvas.width / blockSize;

        // Create the game board
        let board = [];
        for (let row = 0; row < numberOfRows; row++) {
            board[row] = [];
            for (let col = 0; col < numberOfColumns; col++) {
                board[row][col] = 'white';
            }
        }

        // Draw the board
        function drawBoard() {
            for (let row = 0; row < numberOfRows; row++) {
                for (let col = 0; col < numberOfColumns; col++) {
                    drawBlock(col, row, board[row][col]);
                }
            }
        }

        // Draw a block
        function drawBlock(x, y, color) {
            context.fillStyle = color;
            context.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
            context.strokeStyle = 'black';
            context.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
        }

        // Create a Tetromino shape
        function createTetromino(shape, color) {
            return {
                shape: shape,
                color: color,
                x: Math.floor(numberOfColumns / 2) - Math.floor(shape[0].length / 2),
                y: 0
            };
        }

        // Array of Tetromino shapes
        const tetrominoes = [
            [[1, 1, 1, 1]],
            [[1, 1], [1, 1]],
            [[1, 1, 0], [0, 1, 1]],
            [[0, 1, 1], [1, 1, 0]],
            [[1, 1, 1], [0, 1, 0]],
            [[1, 1, 1], [1, 0, 0]]
        ];
        const tetrominoColors = ['cyan', 'yellow', 'purple', 'green', 'red', 'blue'];

        // Create a random Tetromino
        function createRandomTetromino() {
            const randomIndex = Math.floor(Math.random() * tetrominoes.length);
            return createTetromino(tetrominoes[randomIndex], tetrominoColors[randomIndex]);
        }

        // Draw the current Tetromino
        function drawTetromino() {
            for (let row = 0; row < currentTetromino.shape.length; row++) {
                for (let col = 0; col < currentTetromino.shape[row].length; col++) {
                    if (currentTetromino.shape[row][col]) {
                        drawBlock(currentTetromino.x + col, currentTetromino.y + row, currentTetromino.color);
                    }
                }
            }
        }

        // Clear the current Tetromino
        function clearTetromino() {
            for (let row = 0; row < currentTetromino.shape.length; row++) {
                for (let col = 0; col < currentTetromino.shape[row].length; col++) {
                    if (currentTetromino.shape[row][col]) {
                        drawBlock(currentTetromino.x + col, currentTetromino.y + row, 'white');
                    }
                }
            }
        }

        // Move the current Tetromino down
        function moveDown() {
            clearTetromino();
            currentTetromino.y++;
            drawTetromino();
        }

        // Check if a Tetromino can move down
        function canMoveDown() {
            for (let row = 0; row < currentTetromino.shape.length; row++) {
                for (let col = 0; col < currentTetromino.shape[row].length; col++) {
                    if (currentTetromino.shape[row][col]) {
                        if (currentTetromino.y + row >= numberOfRows - 1 || board[currentTetromino.y + row + 1][currentTetromino.x + col] !== 'white') {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // Rotate the current Tetromino
        function rotate() {
            const rotatedShape = [];
            for (let col = 0; col < currentTetromino.shape[0].length; col++) {
                rotatedShape[col] = [];
                for (let row = currentTetromino.shape.length - 1; row >= 0; row--) {
                    rotatedShape[col][currentTetromino.shape.length - 1 - row] = currentTetromino.shape[row][col];
                }
            }

            clearTetromino();
            currentTetromino.shape = rotatedShape;
            drawTetromino();
        }

        // Move the current Tetromino left
        function moveLeft() {
            clearTetromino();
            currentTetromino.x--;
            drawTetromino();
        }

        // Move the current Tetromino right
        function moveRight() {
            clearTetromino();
            currentTetromino.x++;
            drawTetromino();
        }

        // Update the game state
        function update() {
            if (canMoveDown()) {
                moveDown();
            } else {
                // Lock the current Tetromino
                for (let row = 0; row < currentTetromino.shape.length; row++) {
                    for (let col = 0; col < currentTetromino.shape[row].length; col++) {
                        if (currentTetromino.shape[row][col]) {
                            board[currentTetromino.y + row][currentTetromino.x + col] = currentTetromino.color;
                        }
                    }
                }

                // Check for full rows
                for (let row = 0; row < numberOfRows; row++) {
                    if (board[row].every(block => block !== 'white')) {
                        // Remove the full row
                        board.splice(row, 1);
                        // Add an empty row at the top
                        board.unshift(Array(numberOfColumns).fill('white'));
                    }
                }

                currentTetromino = createRandomTetromino();
            }

            drawBoard();
        }

        // Game loop
        let currentTetromino = createRandomTetromino();
        setInterval(update, 1000);

        // Handle keyboard events
        document.addEventListener('keydown', function (event) {
            switch (event.keyCode) {
                case 37: // Left arrow
                    if (currentTetromino.x > 0) {
                        moveLeft();
                    }
                    break;
                case 39: // Right arrow
                    if (currentTetromino.x < numberOfColumns - currentTetromino.shape[0].length) {
                        moveRight();
                    }
                    break;
                case 40: // Down arrow
                    if (canMoveDown()) {
                        moveDown();
                    }
                    break;
                case 38: // Up arrow
                    rotate();
                    break;
            }
        });
    </script>
</body>
</html>
